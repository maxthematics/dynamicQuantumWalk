<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    
    <title>Diskreter 1D-Quanten-Walk</title>
    <style type="text/css">
        * {
            margin: 0px;
            padding: 0px;
        }
        
        #CSConsole {
            background-color: #FAFAFA;
            border-top: 1px solid #333333;
            bottom: 0px;
            height: 200px;
            overflow-y: scroll;
            position: fixed;
            width: 100%;
        }
    </style>
    <link rel="stylesheet" href="https://cindyjs.org/dist/v0.8/CindyJS.css">
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/Cindy.js"></script>
<script id="csinit" type="text/x-cindyscript">

// =====================================================================
// SPRACHE / LANGUAGE
// Setze "de" für Deutsch oder "en" für Englisch
// Set "de" for German or "en" for English
// =====================================================================
lang = "de";

// =====================================================================
// ÜBERSETZUNGEN / TRANSLATIONS
// =====================================================================
translations = [
  ["title",             "Diskreter 1D-Quanten-Walk",              "Discrete 1D Quantum Walk"],
  ["coinBiasTitle",     "Quantenmünze: Bias p",                   "Quantum Coin: Bias p"],
  ["coinBiasHigh",      "p groß: bleiben dominiert (↑→↑, ↓→↓)",   "p large: stay dominates (↑→↑, ↓→↓)"],
  ["coinBiasLow",       "p klein: tauschen dominiert (↑↔↓)",      "p small: swap dominates (↑↔↓)"],
  ["coinPhaseTitle",    "Quantenmünze: Phase φ",                  "Quantum Coin: Phase φ"],
  ["coinPhaseDesc",     "dreht die Kreuzkopplung (↑↔↓)",          "rotates cross-coupling (↑↔↓)"],
  ["coinPhaseReal",     "φ = 0,π: reell (±1) | sonst komplex",    "φ = 0,π: real (±1) | else complex"],
  ["coinMatrixTitle",   "Quantenmünze als Matrix:",               "Quantum coin as matrix:"],
  ["stepsTitle",        "Anzahl Schritte",                        "Number of Steps"],
  ["initPhaseTitle",    "Initiale Phasenwinkel",                  "Initial Phase Angles"],
  ["initPhaseDesc",     "(|↑⟩ rot, |↓⟩ blau)",                    "(|↑⟩ red, |↓⟩ blue)"],
  ["normalized",        "normalisiert",                           "normalized"],
  ["binomialBtn",       "Binomialverteilung (p=.5)",              "Binomial distribution (p=.5)"]
];

tr(key) := (
  idx = if(lang == "de", 2, 3);
  result = key;
  forall(translations, entry,
    if(entry_1 == key, result = entry_idx)
  );
  result
);

//colors
cAlhambraDark = 1/256 * (98, 103, 72);
cAlhambraLight = 1/256 * (202, 213, 183);
cSFBOrange = 1/256 * (242, 196, 111);
cSFBOrangeText = 1/256 * (220, 150, 20);
cSFBBlue = 1/256 * (39, 130, 197);
cDarkBlue = 1/256 * (22, 42, 103);
cLightBlue = 1/256 * (30, 167, 203);
cMiddleBlue = 1/256 * (26, 105, 153);

cLightGray = (.8, .8, .8);
cDarkGray = (.3, .3, .3);

cAlhambraMid = 1/256 * (150, 160, 120);
cOliveGreen = 1/256 * (110, 120, 90);
cMintGreen = 1/256 * (180, 220, 190);

cAnthracite = 1/256 * (50, 50, 50);
cGraphite = 1/256 * (70, 75, 80);
cLightStoneGray = 1/256 * (190, 190, 185);

cTerracotta = 1/256 * (190, 110, 90);
cDeepRed = 1/256 * (140, 40, 40);
cRosewood = 1/256 * (120, 70, 65);

cBrightRed  = 1/256 * (234,  52,  58);
cBrightBlue = 1/256 * ( 25, 145, 255);



//colortest((0,14));
;
//layout
topleft = (0,0);
width = 16;
height = 12;

west = topleft.x;
east = topleft.x + width;
north = topleft.y;
south = topleft.y - height;


controlProportion = .3;
sepX = west + controlProportion * width;
widthCtrl = sepX-west;
widthSim = east-sepX;


sliderWidth = .75*widthCtrl;
initphaseR = 1;

SLC.xy = (west + 1/3*widthCtrl, north - .1*height);
IC.xy = (west + 1/3*widthCtrl , south + .22*height);


C1.xy = (sepX, south);
C2.xy = (east, north);

// color assignment
colDist = cSFBOrange;
colUp = cBrightRed;
colDown = cBrightBlue;
colSlP = cMiddleBlue;
colSlPhi = cMiddleBlue;
colSlN = cDeepRed;
colTeXCoin = cMiddleBlue;
colGauss = cAlhambraMid;

btBinom.text = tr("binomialBtn");
btBinom.color= cAlhambraDark;
btBinom.pressed = false;
gauss = false;

//title
maketitle():= (
drawtext((west-.55, north +.4),tr("title"),
  size -> 30,
  bold -> true,
  color -> cSFBBlue
););


//credits
makefooter():= (
  credits="Max Hoffmann | max.hoffmann@math.upb.de | v2025Oct26";
  funding="Supported by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) – Project-ID 491392403 – TRR 358";

  drawtext((east+2, south-.6),credits,
    color -> cSFBBlue,
    align -> "right",
    size -> 12
  );

  drawtext((east+2, south-.6),funding,
    color -> cSFBBlue,
    align -> "right",
    size -> 10,
    yoffset -> -15
  );
);
;

//parameter
maxmaxSteps = 100;
maxSteps= maxmaxSteps;

//particle = [1+0*i, 0+0*i];
particle = [1/sqrt(2), i/sqrt(2)];

//coin
coinP = .5;
coinRot = 0;

// Toggle: normalize bars so the tallest reaches the full height
distNormalizeToMax = true;   // set false for physically linear heights

gauss = false;
;
//model
N = 2*maxSteps + 1;
mid = maxSteps+1;

up(particle) := particle_1;
down(particle) := particle_2;
setUp(particle, newUp) := [newUp, down(particle)];
setDown(particle, newDown) := [up(particle), newDown];

upAngle(particle) := arctan2(up(particle));
downAngle(particle) := arctan2(down(particle));

upAbs(particle) := abs(up(particle));
downAbs(particle) := abs(down(particle));


// phase rotation
cis(phi) := cos(phi) + i*sin(phi);

coinGen(p, phi) := [
  [ sqrt(p),              cis(phi)*sqrt(1-p) ],
  [ cis(-phi)*sqrt(1-p), -sqrt(p)            ]
];

coin = coinGen(coinP, coinRot);

initState = apply(1..N,[0+0*i, 0+0*i]);
initState_mid = particle;


;
//control
walkstep (state) := (
  afterCoin = apply(state,coin*#);

  N = length(state);  
  nextstate = apply(1..N, [0+0*i,0+0*i]);
  forall(1..N, j, (
      L := up(afterCoin_j);
      R := down(afterCoin_j);
      if(j>1, nextstate_(j-1) = setUp(nextstate_(j-1), up(nextstate_(j-1)) + L));
      if(j<N, nextstate_(j+1) = setDown(nextstate_(j+1), down(nextstate_(j+1)) + R));
    )
  );

  nextstate;
);
;

//drawDist
probsOf(state) := apply(1..length(state), j, abs(state_j_1)^2 + abs(state_j_2)^2);
maxOf(L) := (
  n = length(L);
  if(n == 0, 0,
    (m = L_1; forall(2..n, k, if(L_k > m, m = L_k)); m)
  )
);

// simple nCk without overflow
comb(n, k) := (
  if(k < 0 % k > n, 0,
    (kk = min(k, n-k);
     p = 1;
     if(kk > 0, forall(1..kk, i, p = p * (n - kk + i) / i));
     p)
  )
);

drawDist(state, center, size) := (
  // early exit if nothing to draw
  if(length(state) == 0, (), (
    P = probsOf(state);
    N = length(P);
    if(N == 0, ());                      // no bars -> nothing to do

    cx = center_1; cy = center_2;
    w  = size_1;   h  = size_2;

    // scale: either linear (sc=1) or normalized so max(P)*sc = 1
    pmax = maxOf(P);
    sc   = if(distNormalizeToMax & (pmax > 0), 1/pmax, 1);

    x0 = cx - w/2;  y0 = cy;
    bw = w / N;

    // optional axis
    draw([x0, y0], [x0 + w, y0], color->cAnthracite);


    pad = 0.05*bw;
    forall(1..N, j, (
      xL = x0 + (j-1)*bw + pad;
      xR = x0 + j*bw       - pad;
      bh = (P_j * sc) * h;
      if(bh > 0,
        fillpoly([[xL,y0],[xR,y0],[xR,y0+bh],[xL,y0+bh]],
                 color->colDist, alpha->1)
      );
    ));

    
    // ---------- optional: classical binomial overlay in the background ----------
    if(gauss,
      (
        // infer step count s from visible slice length N ≈ 2s+1
        s  = round((N - 1) / 2);
        m  = 1 + floor((N - 1)/2);     // local middle index of this slice
        pC = 0.5;                       // classical coin bias (change if desired)

        // draw binomial bars first (background)
        forall(1..N, j, (
          d = j - m;                    // displacement from center
          // parity + bounds: only positions with same parity as s are allowed
          if(abs(d) <= s & (mod(abs(d),2) == mod(s,2)),
            (
              k  = (s + d)/2;           // # of right steps
              pg = comb(s, k) * pC^k * (1 - pC)^(s - k);  // binomial pmf
              bhg = (pg * sc) * h;      // scale like quantum bars
              if(bhg > 0,
                (
                  xL = x0 + (j-1)*bw + pad+.3*bw;
                  xR = x0 + j*bw       - pad-.3*bw;
                  fillpoly([[xL,y0],[xR,y0],[xR,y0+bhg],[xL,y0+bhg]],
                           color->colGauss, alpha->1);
                )
              );
            )
          );
        ));
      )
    );



    if(distNormalizeToMax,
      drawtext([x0 + w, y0+1.05*h], tr("normalized") + "
max p ≈ " + format(pmax, 4),
               align->"left", size->12, color -> cSFBOrangeText)
    );
  ));
);


//phaseplot
// --- helpers: minimal & safe ---
// local middle index from the state's length
midOf(state) := 1 + floor((length(state) - 1) / 2);

// reachable range [jL, jR] for step s using local mid
reachableRange(state, s) := (
  N = length(state);
  m = midOf(state);
  jL = max(1, m - s);
  jR = min(N, m + s);
  [jL, jR]
);

// cut to reachable slice; never returns empty (falls back to the real middle site)
cutStateToReachable(state, s) := (
  R  = reachableRange(state, s);
  jL = R_1; jR = R_2;
  if(jL > jR,
     [ state_(midOf(state)) ],
     apply(jL..jR, j, state_j)
  )
);
phase(z) := if(abs(z)==0, 0, arctan2(re(z), im(z)));

arrowAlpha = 1;
thickK = 4;

drawArrow(c, len, phi, col, a, sz) := (
  v = [cos(phi), sin(phi)];
  p2 = [c_1 + len*v_1, c_2 + len*v_2];
  draw(c, p2, color->col, alpha->a, size->sz);
);

drawSite(center, r, s) := (
  // circle
  fillcircle(center, r, color->cLightGray, alpha->.1);
  drawcircle(center, r, color->cDarkGray, alpha->.5);

  // konstante Strichdicke
  arrowSizePx = 3.0;
  epsAmp = 1e-6;
  
  alphaGamma = .6;
  ampAlpha(L) := L^alphaGamma;


  // up (red)
  Lu   = abs(s_1);
  phiu = if(Lu==0, 0, arctan2(re(s_1), im(s_1)));
  if(Lu > epsAmp,
    drawArrow(center, r*Lu, phiu,  colUp,   ampAlpha(Lu), arrowSizePx);
  );

  // down (blue)
  Ld   = abs(s_2);
  phid = if(Ld==0, 0, arctan2(re(s_2), im(s_2)));
  if(Ld > epsAmp,
    drawArrow(center, r*Ld, phid,  colDown, ampAlpha(Ld), arrowSizePx);
  );
  
);

// reachable after stepCount steps?  |colindex-mid ≤ stepCount  and  (|colindex-mid| + stepCount) even
isReachable(colIndex, stepCount) := (
  distFromMid = abs(colIndex - mid);
  (distFromMid <= stepCount) & (mod(distFromMid,2) == mod(stepCount,2))
);

drawWalkBoard(walk, origin, dx, dy, r) := (
  upperCenterX = origin_1;
  upperCenterY = origin_2;
  numRows  = length(walk);

  forall(1..numRows, rno, (
    state = walk_rno;
    numSites = length(state);
    stepCount = rno - 1;  
    y = upperCenterY - (numRows-rno) * dy;

    forall(1..numSites, j, (
      if(isReachable(j, stepCount),
        (
          x = upperCenterX + (j - mid) * dx;
          drawSite([x,y], r, state_j);
        )
      );
    ));
  ));
);

last(L) := L_(length(L));

drawWalkInRectWithFrac(walk, BL, TR, histFrac, gap) := (
  // --- outer rectangle ---
  xL = BL_1; yB = BL_2; xR = TR_1; yT = TR_2;
  W  = xR - xL;         H  = yT - yB;
  if(W <= 0 % H <= 0, return());

  // --- time/space ---
  T = length(walk);                 if(T == 0, return());
  S = walk_(-1);                    // last state
  Np = length(S);                   if(Np == 0, return());
  s = T - 1;                        // last step count (>=0)
  mLoc = 1 + floor((Np - 1)/2);     // local middle index of S

  // --- split height ---
  f = max(0, min(1, histFrac));
  Hhist  = f * H;
  Hboard = H - Hhist;

  // --- column spacing fitted to the reachable width (2s+1 columns) ---
  Nused = 2*s + 1;                  // reachable columns at step s
  dx    = W / Nused;

  // --- circle radius + row spacing ---
  rH = 0.5 * dx;
  rV = if(T > 0, Hboard / (2*T), Hboard/2);
  r  = 0.98 * min(rH, rV);
  dy = if(T > 1, (Hboard - 2*r) / (T - 1), 0);

  // --- TOP-CENTER for the board (keep visual center fixed) ---
  xC   = xL + W/2;
  topX = xC + (mid - mLoc) * dx;    // compensate if global 'mid' ≠ local middle
  topY = yB + Hboard - r;

  // 1) board
  drawWalkBoard(walk, [topX, topY], dx, dy, r);

  // 2) histogram over reachable slice ONLY, spanning FULL width W
  jL   = max(1, mLoc - s);
  jR   = min(Np, mLoc + s);
  subS = apply(jL..jR, j, S_j);     // contiguous slice, length = Nused

  // geometry: baseline just above top row; bars fill full width
  gapEff = gap;
  yAxis  = topY + r + gapEff;
  hUsed  = max(0.000001, Hhist - gapEff);  // tiny clamp so height is never 0
  cxDist = xC;                             // center of the rectangle
  wUsed  = W;                              // bars span the full available width

  // 3) distribution (uses your unchanged drawDist signature)
  drawDist(subS, [cxDist, yAxis], [wUsed, hUsed]);
);
;

//slider
// Draws a box around the coin UI (p-slider, phi-slider, matrix)
// x,y  : same anchor you pass to makeslider (center of rails)
// l    : same length as in makeslider
// hdist: same vertical spacing as in makeslider
// padX : extra horizontal padding (world units)
// padY : extra vertical padding (world units)
// fillA: optional fill alpha (0 = no fill)
drawCoinPanelBox(x, y, l, hdist, padX, padY, fillA) := (
  // same header geometry as in makeslider
  titleGapP = 0.3;  lineStepP = 0.3;

  // horizontal span: rails go from x - 0.5*l to x + 0.5*l
  xL = (x - 0.5*l) - padX;
  xR = (x + 0.5*l) + padX;

  // vertical span:
  // top = top line of p-header; bottom = matrix block baseline minus a safe margin
  yTop = y + titleGapP + 2*lineStepP;
  yMatBase = y - 2.2*hdist;    // same offset you use for the matrix placement
  yBot = yMatBase - 0.9;       // small fudge below the TeX box

  yB = yBot - padY;
  yT = yTop + padY;

  // optional soft fill
  if(fillA > 0,
    fillpoly([[xL,yB],[xR,yB],[xR,yT],[xL,yT]], color->colSlP, alpha->fillA)
  );

  // frame
  draw([xL,yB],[xR,yB], color->colSlP, size->1.6);
  draw([xR,yB],[xR,yT], color->colSlP, size->1.6);
  draw([xR,yT],[xL,yT], color->colSlP, size->1.6);
  draw([xL,yT],[xL,yB], color->colSlP, size->1.6);
);

makeslider(x, y, l, hdist) := (
  // ---------- Slider: Bias p ----------
  // rail geometry (must exist before we compute header positions)
  slCoinpY = y;
  slCoinpS = (x - 0.5*l, slCoinpY);
  slCoinpE = (x + 0.5*l, slCoinpY);

  // header (left-aligned at rail start)
  titleGap = 0.3;  lineStep = 0.3;
  xText = slCoinpS.x;
  yTop  = slCoinpY + titleGap + 2*lineStep;

  drawtext((xText, yTop),                 tr("coinBiasTitle"),                 align->"left", size->14, color->colSlP);
  drawtext((xText, yTop - lineStep),      tr("coinBiasHigh"), align->"left", size->12, color->colSlP);
  drawtext((xText, yTop - 2*lineStep),    tr("coinBiasLow"),    align->"left", size->12, color->colSlP);

  // rail + ticks
  draw(slCoinpS, slCoinpE, color->colSlP);
  snapVals = [0, 0.25, 0.5, 0.75, 1];
  snapEps  = 0.03;
  tickGap  = -0.1;  tickLen = 0.2;

  forall(snapVals, s, (
    xt = slCoinpS.x + s*l;
    draw((xt, slCoinpY - tickGap), (xt, slCoinpY - tickGap - tickLen), color->colSlP);
    drawtext((xt, slCoinpY - tickGap - tickLen - 0.3), format(s, 2), align->"mid", color->colSlP);
  ));

  // handle + snapping
  slCoinpP.color = colSlP;
  slCoinpP.y = slCoinpY;
  slCoinpP.x = min(slCoinpE.x, max(slCoinpS.x, slCoinpP.x));

  tRaw = |slCoinpP, slCoinpS| / l;
  nearest = tRaw; mind = 2;
  forall(snapVals, s, if(abs(tRaw - s) < mind, (mind = abs(tRaw - s); nearest = s)));
  t = if(mind < snapEps, nearest, tRaw);
  slCoinpP.x = slCoinpS.x + t*l;
  coinP = t;

  // ---------- Slider: Phase φ (π/2 snaps) ----------
  slPhiY = y - hdist;
  slPhiS = (x - 0.5*l, slPhiY);
  slPhiE = (x + 0.5*l, slPhiY);

  titleGapPhi = 0.3;  lineStepPhi = 0.33;
  xTextPhi = slPhiS.x;
  yTopPhi  = slPhiY + titleGapPhi + 2*lineStepPhi;

  drawtext((xTextPhi, yTopPhi),                 tr("coinPhaseTitle"),            align->"left", size->14, color->colSlPhi);
  drawtext((xTextPhi, yTopPhi - lineStepPhi),   tr("coinPhaseDesc"),    align->"left", size->12, color->colSlPhi);
  drawtext((xTextPhi, yTopPhi - 2*lineStepPhi), tr("coinPhaseReal"), align->"left", size->12, color->colSlPhi);

  draw(slPhiS, slPhiE, color->colSlPhi);

  phiSnapVals = [0, 0.25, 0.5, 0.75, 1];
  phiSnapEps  = 0.03;  phiTickGap = -0.1;  phiTickLen = 0.2;

  phiTickLabel(s) := if(s==0,"0", if(s==0.25,"π/2", if(s==0.5,"π", if(s==0.75,"3π/2","2π"))));
  forall(phiSnapVals, s, (
    xt = slPhiS.x + s*l;
    draw((xt, slPhiY - phiTickGap), (xt, slPhiY - phiTickGap - phiTickLen), color->colSlPhi);
    drawtext((xt, slPhiY - phiTickGap - phiTickLen - 0.3), phiTickLabel(s), align->"mid", color->colSlPhi);
  ));

  slCoinPhiP.color = colSlPhi;
  slCoinPhiP.y = slPhiY;
  slCoinPhiP.x = min(slPhiE.x, max(slPhiS.x, slCoinPhiP.x));

  tPhiRaw = |slCoinPhiP, slPhiS| / l;
  nearestPhi = tPhiRaw; mindPhi = 2;
  forall(phiSnapVals, s, if(abs(tPhiRaw - s) < mindPhi, (mindPhi = abs(tPhiRaw - s); nearestPhi = s)));
  tPhi = if(mindPhi < phiSnapEps, nearestPhi, tPhiRaw);
  slCoinPhiP.x = slPhiS.x + tPhi*l;
  coinRot = 2*pi*tPhi;

  // ---------- Symbolic matrix (TeX) ----------
  drawtext((x, y - 2.2*hdist + 0.75),
           tr("coinMatrixTitle"),
           align->"center", size->14, color->colSlP);
drawtext((x, y-2.2*hdist),
"$U(p,\phi)=\begin{pmatrix}\sqrt{p} & e^{i\phi}\sqrt{1-p}\\ e^{-i\phi}\sqrt{1-p} & -\sqrt{p}\end{pmatrix}$",
align->"mid", size->14, color->colTeXCoin);

  // ---------- Slider: Anzahl Schritte N ----------
  slMaxStepY = y - 5.5*hdist;
  slMaxStepS = (x - 0.5*l, slMaxStepY);
  slMaxStepE = (x + 0.5*l, slMaxStepY);

  titleGapN = 0.3;  lineStepN = 0.30;
  xTextN = slMaxStepS.x;
  yTopN  = slMaxStepY + titleGapN + 1*lineStepN;

  drawtext((xTextN, yTopN), tr("stepsTitle"), align->"left", size->14, color->colSlN);
  draw(slMaxStepS, slMaxStepE, color->colSlN);

  // ticks/labels: 0,50,100,...,M (M=maxmaxSteps)
  tickGapN = -0.1;  tickLenN = 0.2;  M = max(0, round(maxmaxSteps));  stepLbl = 50;
  if(M == 0,
    (
      xt = slMaxStepS.x;
      draw((xt, slMaxStepY - tickGapN), (xt, slMaxStepY - tickGapN - tickLenN), color->colSlN);
      drawtext((xt, slMaxStepY - tickGapN - tickLenN - 0.3), "0", align->"mid", color->colSlN);
    ),
    (
      kMax = floor(M/stepLbl);
      forall(0..kMax, k, (
        nTick = k*stepLbl;
        tTick = nTick / M;
        xt    = slMaxStepS.x + tTick*l;
        draw((xt, slMaxStepY - tickGapN), (xt, slMaxStepY - tickGapN - tickLenN), color->colSlN);
        drawtext((xt, slMaxStepY - tickGapN - tickLenN - 0.3), "" + nTick, align->"mid", color->colSlN);
      ));
      if(mod(M, stepLbl) != 0, (
        xt = slMaxStepE.x;
        draw((xt, slMaxStepY - tickGapN), (xt, slMaxStepY - tickGapN - tickLenN), color->colSlN);
        drawtext((xt, slMaxStepY - tickGapN - tickLenN - 0.3), "" + M, align->"mid", color->colSlN);
      ));
    )
  );

  // handle + integer snap
  slMaxStepP.color = colSlN;
  slMaxStepP.y = slMaxStepY;
  slMaxStepP.x = min(slMaxStepE.x, max(slMaxStepS.x, slMaxStepP.x));

  tNraw = if(l>0, |slMaxStepP, slMaxStepS|/l, 0);
  Nraw  = round(tNraw * maxmaxSteps);
  Nraw  = min(maxmaxSteps, max(0, Nraw));
  tN    = if(maxmaxSteps>0, Nraw/maxmaxSteps, 0);
  slMaxStepP.x = slMaxStepS.x + tN*l;
  maxSteps = Nraw;

  // live value under the header
  drawtext((xTextN, yTopN - lineStepN), "N = " + maxSteps, align->"left", size->12, color->colSlN);

  // refresh coin from sliders
  coin = coinGen(coinP, coinRot);
);

// ---------- initial handle placement + call ----------
sliderMx = SLC.x;
sliderMy = SLC.y;
sliderL  = sliderWidth;

slCoinpP.x    = sliderMx;
slCoinPhiP.x  = sliderMx - 0.5*sliderL;
slMaxStepP.x  = (sliderMx - 0.5*sliderL) + (5/maxmaxSteps)*sliderL;

makeslider(sliderMx, sliderMy, sliderL, 2);
drawCoinPanelBox(sliderMx, sliderMy, sliderL, 2, 0.35, 0.35, 0.06);
;
//initphase
// Unicode Brackets
bra = "\u27E8";  // ⟨
ket = "\u27E9";  // ⟩


// wrap angle to (-pi, pi]
wrapPi(a) := (
  b = a - 2*pi*floor((a + pi)/(2*pi));
  if(b<=-pi, b+2*pi, b)
);

// pretty-print as multiple of π (e.g. -0.5π, 1.25π)
formatPi(phi) := (
  k = round((phi/pi)*100)/100;           // 2 decimal multiples of π
  if(abs(k) < 1e-9, "0",
    if(abs(k-1) < 1e-9, "π",
      if(abs(k+1) < 1e-9, "-π",
        format(k,2) + "π"
      )
    )
  )
);

initphase(c, r, set) := (
  if(set,
    (
      downP.xy   = c + (0, r*sqrt(.5));
      upP.xy = c + (r*sqrt(.5), 0);
    ),
    (
      upP.xy = c + min(r, |c,upP.xy|) * (upP - c)/|c,upP.xy|;
      downP.xy = c + sqrt(abs(r^2 - |c, upP|^2)) *
                        if(|c, downP| > 0.0001, (downP - c)/|c, downP|, [1, 0]);
    )
  );

  upP.color = colUp;    downP.color = colDown;
  upP.size  = 5;        downP.size  = 5;

  // node
  fillcircle(c, r, color->cLightGray, alpha->.1);
  drawcircle(c, r, color->cDarkGray,  alpha->.5);

  // spokes
  draw(c, upP,   color->colUp,   size->2);
  draw(c, downP, color->colDown, size->2);

  // map knob positions to complex amplitudes on the unit circle
  zUp   = (upP.xy   - c) / r;
  zDown = (downP.xy - c) / r;

  complexUp   = zUp.x   + i*zUp.y;
  complexDown = zDown.x + i*zDown.y;

  // phases (CCW), relative phase
  thetaUp   = arctan2(im(complexUp),   re(complexUp));
  thetaDown = arctan2(im(complexDown), re(complexDown));
  dTheta    = wrapPi(thetaDown - thetaUp);

  // build the start particle
  particle       = [complexUp, complexDown];
  initState_mid  = particle;

  // -------- labels --------
  // layout gaps relative to radius
  gapTop    = 0.5*r;     // space above the circle
  gapBottom = 0.4*r;     // space below the circle

  // title centered above
  drawtext(c + (0, r + gapTop),
           tr("initPhaseTitle") + "
" + tr("initPhaseDesc"),
           align->"center", size->14, color->cAnthracite);

  // relative phase centered below (Δθ in π-Notation)
  drawtext(c + (0, -r - gapBottom),
           "Δθ ≈ " + formatPi(dTheta),
           align->"center", size->14, color->cSFBOrangeText);
);

initphase(IC, initphaseR, true);
maketitle();
makefooter()
;

</script>
<script id="csdraw" type="text/x-cindyscript">
//Script (CindyScript)
maketitle();
makefooter();
walk = [initState];
repeat(maxSteps,
  walk = walk ++ [walkstep(walk_(-1))]
);

// --- build rectangle from two draggable points C1, C2 (points, not lists) ---
BL = [min(C1.x, C2.x), min(C1.y, C2.y)];   // bottom-left
TR = [max(C1.x, C2.x), max(C1.y, C2.y)];   // top-right

// --- choose fractions/gap ---
histFrac = 1/3;     // top area for histogram (0..1)
gap      = 0.05;    // small vertical gap above the top row

// --- draw everything packed into [BL, TR] ---
drawWalkInRectWithFrac(walk, BL, TR, histFrac, gap);
;
//Script (CindyScript)
//slider p
makeslider(SLC.x,SLC.y,sliderL,2);
drawCoinPanelBox(sliderMx, sliderMy, sliderL, 2, 0.35, 0.35, 0.06);
initphase(IC, initphaseR, false);

;

</script>
    <script type="text/javascript">
var cdy = CindyJS({
  scripts: "cs*",
  defaultAppearance: {
    dimDependent: 0.7,
    fontFamily: "sans-serif",
    lineSize: 1,
    pointSize: 5.0,
    textsize: 12.0
  },
  angleUnit: "°",
  geometry: [
    {name: "slCoinpP", type: "Free", pos: [4.0, -2.999999999999999, 2.4999999999999996], dimDependent: 1, color: [0.098, 0.408, 0.596]},
    {name: "slCoinPhiP", type: "Free", pos: [-0.24999999999999967, -4.0, 1.2499999999999998], dimDependent: 1, color: [0.098, 0.408, 0.596]},
    {name: "slMaxStepP", type: "Free", pos: [0.07606557377049188, -4.0, 0.3278688524590164], dimDependent: 1, color: [0.545, 0.153, 0.153]},
    {name: "upP", type: "Free", pos: [0.98594306888314, -4.0, 0.4273504273504274], dimDependent: 1, color: [0.914, 0.2, 0.224], border: false},
    {name: "downP", type: "Free", pos: [0.7396370021168036, -4.0, 0.4622731263230022], dimDependent: 1, color: [0.094, 0.565, 0.996]},
    {name: "C1", type: "Free", pos: [1.5999999999999999, -4.0, 0.3333333333333333], color: [0.831, 0.639, 1.0], visible: false, size: 3.0},
    {name: "C2", type: "Free", pos: [4.0, 0.0, 0.25], color: [0.831, 0.639, 1.0], visible: false, size: 2.0},
    {name: "SLC", type: "Free", pos: [4.0, -3.000000000000001, 2.5], color: [0.012, 0.655, 0.737], visible: false},
    {name: "IC", type: "Free", pos: [0.6837606837606838, -4.0, 0.4273504273504274], color: [0.51, 0.949, 1.0], visible: false},
    {name: "btBinom", type: "ToggleButton", pos: [4.0, -0.8837073589422092, 0.24749589166059843], dimDependent: 1, color: [0.38, 0.4, 0.278], fillcolor: [1.0, 1.0, 1.0], fillalpha: 0.27272728085517883, script: "gauss = !gauss;", text: "Binomialverteilung (p=.5)"}
  ],
  ports: [{
    width: 1270,
    height: 802,
    id: "CSCanvas",
    transform: [{visibleRect: [-0.9706238028914589, 1.0621361735229418, 18.872773795333536, -13.46889128614355]}],
    background: "rgb(255,255,255)"
  }],
  csconsole: false,
  use: ["katex"],
  cinderella: {build: 2091, version: [3, 0, 2091]}
});
    </script>
</head>
<body>
    <div id="CSCanvas"></div>
</body>
</html>